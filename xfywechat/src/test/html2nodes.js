var cheerio = require('cheerio'),
$ = cheerio.load('<div class="field field-name-body field-type-text-with-summary field-label-hidden"><div class="field-items"><div class="field-item even" property="content:encoded"><p>过去，JavaScript的变量声明机制不像C语言一样，在声明变量的同时也会创建变量（绑定）。在以前的JavaScript中何时创建变量要看怎么声明变量。在以前的变量作用域有全局作用域和局部作用域，但不像其他的程序语言有块作用域一说。在ES6中新引入的块级作用域绑定机制。</p>↵↵<h2><code>var</code>声明及变量提升</h2>↵↵<p>在函数作用域或全局作用域中通过<code>var</code>声明的变量，不管是在哪声明的，都会被当成在当前作用域顶部声明的变量，这也被称之为<strong>变量提升</strong>。拿个示例来说：</p>↵↵<pre><code>function getValue (condition) {↵    console.log(value);        // =&gt; undefined↵    if (condition) {↵        var value = 'w3cplus';↵        console.log(value);   // =&gt; w3cplus ↵        return value;         // =&gt; 如果condition为true,返回w3cplus↵    } else {↵        console.log(value);   // =&gt; undefined↵        return null;          // =&gt; 如果condition为false，返回null↵    }↵    console.log(value);       // =&gt; undefined↵}↵getValue(true);  // =&gt; w3cplus↵getValue(false); // =&gt; null↵</code></pre>↵↵<p>刚接触JavaScript的时候，一直以为<code>condition</code>为<code>true</code>时才会创建<code>value</code>变量。而事实上，不管<code>condition</code>不管是为<code>true</code>还是<code>false</code>都已经创建了<code>value</code>变量。在预编译阶段，JavaScript引擎会将上面的<code>getValue()</code>函数修改成：</p>↵↵<pre><code>function getValue(condition) {↵    var value;↵    console.log(value);↵↵    if (condition) {↵        var value = 'w3cplus';↵        console.log(value);↵        return value;↵    } else {↵        console.log(value);↵        return null;↵    }↵    console.log(value);↵}↵</code></pre>↵↵<p>变量<code>value</code>被提升到函数顶部，而初始化操作依旧留在原处执行，这也就是说<code>else {}</code> 中也可以访问到<code>value</code>变量，而且此时的<code>value</code>并未初始化，所以其值为<code>undefined</code>。</p>↵↵<p>变量提升，简单的理解，就是把变量提升至函数的最顶部地方。需要说明的是：<strong>变量提升只是提升变量的声明，并不会把赋值也提升上来，没有赋值的变量初始值是<code>undefined</code></strong>。所以上面就出现了声明为<code>undefined</code>的<code>var</code>，因为赋值在后面声明提升在了前面。</p>↵↵<p>还有一点需要注意的是因为JavaScript是函数级作用域，只有函数才会创建新的作用域，而不像其他语言有块级作用域，比如<code>if</code>语句块。就上面的示例而言，不管会不会进入<code>if</code>语句块，函数声明都会提升到当前作用域的顶部，得到执行。在JavaScript并不会创建一个新的作用域。</p>↵↵<p>扩展阅读：</p>↵↵<ul>↵<li><a href="//www.w3cplus.com/javascript/javascript-hoisting-in-details.html">JavaScript的变量：变量提升</a></li>↵<li><a href="//www.w3cplus.com/javascript/the-scope-in-javascript-explained.html">JavaScript中的作用域</a></li>↵<li><a href="//developer.mozilla.org/zh-CN/docs/Glossary/Hoisting">变量提升</a></li>↵<li><a href="//www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014344993159773a464f34e1724700a6d5dd9e235ceb7c000">变量作用域</a></li>↵<li><a href="//yanhaijing.com/javascript/2014/04/30/JavaScript-Scoping-and-Hoisting/">JavaScript的作用域和提升机制 </a></li>↵<li><a href="//www.html-js.com/article/Scope-and-context-learning-every-day-JavaScript-article-understand-Javascript">一篇文章弄懂JavaScript中作用域和上下文</a></li>↵<li><a href="//python.freelycode.com/contribution/detail/701">深入理解javascript中的作用域</a></li>↵<li><a href="//bubkoo.com/2014/03/10/explaining-javascript-scope-and-closures/">解释 JavaScript 的作用域和闭包</a></li>↵<li><a href="//blog.rainy.im/2015/07/04/scope-chain-and-prototype-chain-in-js/">图解Javascript上下文与作用域</a></li>↵</ul>↵↵<h2>块级声明</h2>↵↵<p>把上面的示例做一下调整，如下：</p>↵↵<pre><code>console.log(value);  // =&gt; ReferenceError: value is not defined↵function getValue(condition) {↵    console.log(value); // =&gt; undefined↵↵    if (condition) {↵        var value = 'w3cplus';↵        console.log(value); // =&gt; 如查condition为true, 输出w3cplus↵        return value;↵    } else {↵        console.log(value); // =&gt; 如果condition为false, 输出undefined↵        return null;↵    }↵    console.log(value); // =&gt; undefined↵}↵↵getValue(true);  // =&gt; w3cplus ↵getValue(false); // =&gt; null↵</code></pre>↵↵<p>在函数外调用<code>value</code>会报错<code>ReferenceError: value is not defined</code>错误信息。也就是说在函数体内声明的变量，在函数体外是无法调用的。这里就涉及到了全局作用域和局部作用域相关的概念。这里暂且不说。但在函数内部的我们称之为<strong>块级作用域</strong>。上面的示例也说明，块级里面声明的变量只能经块级作用域中使用，在指定块的作用域之外无法访问块级声明。简而言之，<strong>块内声明的变量，在块外无法使用</strong>。</p>↵↵<p>在JavaScript中块级作用域不仅存在于函数内部，也存在于块中，比如<code>{}</code>（<code>if</code>，<code>for</code>这样的语块）。如果在<code>if</code>或<code>for</code>这样的语句块中，使用<code>var</code>声明的变量，在外部（除函数体外）是可以被访问到的，只不过有可能其值是<code>undefined</code>。为了让JavaScript中能像其他的程序语言一样，所以引入了块级作用域，让JavaScript变得更灵活也更普通。</p>↵↵<h3><code>let</code>和<code>const</code></h3>↵↵<p>在ES6中引入了<code>let</code>和<code>const</code>关键词用来声明变量。<code>let</code>和<code>var</code>类似都是用来声明变量的，不同的是，<code>let</code>声明的变量的作用域名限制在当前代码块中。比如文章开头的示例，把<code>if</code>语句块中的<code>var</code>替换成<code>let</code>，结果就又将不一样：</p>↵↵<pre><code>function getValue(condition) {↵    console.log(value);  // =&gt; ReferenceError: value is not defined↵    if (condition) {↵        let value = 'w3cplus';↵        console.log(value); // =&gt; w3cplus↵        return value; // =&gt; w3cplus↵    } else {↵        console.log(value); // =&gt; 如果condition为false，程序执行到此报错：ReferenceError: value is not defined↵        return null;↵    }↵    console.log(value); // =&gt; ReferenceError: value is not defined↵}↵getValue(true);↵</code></pre>↵↵<p>由<code>let</code>声明的变量，不会像<co…<code>const</code>声明的常量，是不能修改的。这样一来就报<code>TypeError</code>错误。所以说，如果后续循环体内不会修改该变量，那么就可以使用<code>const</code>来声明，否则不能使用<code>const</code>声明变量。</p>↵↵<p>在<code>for-in</code>或<code>for-of</code>循环中使用<code>const</code>时的行为与使用<code>let</code>一致。比如下面的代码就不会报错：</p>↵↵<pre><code>var funcs = [];↵var obj = {↵    name: 'w3cplus'.↵    age: 7,↵    job: 'FE'↵};↵↵for (const key in obj) {↵    funcs.push(function (){↵        console.log(key);↵    })↵}↵↵funcs.map(function(x){↵    return x(); // =&gt; name, age, job↵})↵</code></pre>↵↵<p><code>const</code>在<code>for-in</code>和<code>for-of</code>循环中能正常运行，那是因为每次迭代不会像<code>for</code>循环一样修改已有绑定，而是会创建一个新绑定。</p>↵↵<h2>全局块作用域绑定</h2>↵↵<p><code>let</code>和<code>const</code>与<code>var</code>的另一个区别是它们在全局作用域中的行为。当<code>var</code>被用于全局作用域时，它会创建一个新的全局变量作为全局对象的属性。这意味着用<code>var</code>很可能会无意中覆盖一个已经存在的全局变量，如下：</p>↵↵<pre><code>// 在浏览器中↵var RegExp = 'w3cplus';↵console.log(window.RegExp); // =&gt; w3cplus↵↵var name = 'damo';↵console.log(window.name); // =&gt; damo↵</code></pre>↵↵<p>如果在全局作用域中使用<code>let</code>或<code>const</code>，会在全局作用域下创建一个新的绑定，但该绑定不会添加为全局对象的属性。换句话说， <strong>用<code>let</code>或<code>const</code>不能覆盖全局变量，而只能遮蔽它</strong>。如此一来，如果不想为全局对象创建属性，则使用<code>let</code>和<code>const</code>要安全得多。</p>↵↵<h2><code>var</code> 和 <code>let</code></h2>↵↵<p>简单的概括一下：</p>↵↵<ul>↵<li>通过<code>var</code>声明的变量，它的作用域是在<code>function</code>或任何外部已经被声明的<code>function</code>，是全域的</li>↵<li>通过<code>let</code>声明的变量，它的作用域是在一个块</li>↵</ul>↵↵<p>比如：</p>↵↵<pre><code>function varvslet() {↵    console.log(i); // i 是 undefined 的，因为变量提升↵    // console.log(j); // ReferenceError: j 没有被定义↵↵    for( var i = 0; i &lt; 3; i++ ) {↵        console.log(i); // 0, 1, 2↵    };↵↵    console.log(i); // 3↵    // console.log(j); // ReferenceError: j 没有被定义↵↵    for( let j = 0; j &lt; 3; j++ ) {↵        console.log(j);↵    };↵↵    console.log(i); // 3↵    // console.log(j); // ReferenceError: j 没有被定义↵}↵</code></pre>↵↵<p>两者区别：</p>↵↵<ul>↵<li><strong>变量提升：</strong> <code>let</code>不会被提升到整个块的作用域。相比之下，<code>var</code>可以被提升</li>↵<li><strong>循环中的闭包：</strong> <code>let</code>在每次循环可以重新被绑定，确保在它之前结束的循环被重新赋值，所以在闭名中它被用来避免一些问题</li>↵</ul>↵↵<p>那我们应该用<code>let</code>替代<code>var</code>吗？</p>↵↵<blockquote>↵  <p>不是的，<code>let</code> 是新的块作用域。语法强调在 <code>var</code> 已经是区块作用域时，<code>let</code> 应该替换 <code>var</code> ，否则请不要替换 <code>var</code>。<code>let</code> 改善了在 JavaScript 作用域的选项，而不是取代。<code>var</code> 对于变量依旧是有用的，可被用在整个 <code>function</code> 之中。</p>↵</blockquote>↵↵<h2>块级绑定最佳实践</h2>↵↵<p>很多人都认为，在ES6中应该默认使用<code>let</code>而不是<code>var</code>。对于很多JavaScript开发者而言，<code>let</code>实际上与他们想要的<code>var</code>一样，直接替换也符合逻辑。这种情况下，对于需要写保护的变量则要使用<code>const</code>。</p>↵↵<p>如果你开始使用ES6的话，默认使用<code>const</code>，只有确实需要改变变量的值时使用<code>let</code>。因为大部分变量的值在初始化之后不应该再改变，而预料外的变量值的改变是很多Bug的源头。</p>↵↵<h2>总结</h2>↵↵<p>块级作用域绑定的<code>let</code>和<code>const</code>为JavaScript引入词法作用域，它们声明的变量不会提升，而且只可以在声明这些变量的代码块中使用。虽然这个功能给我们带来很多方便之处，但也存在一个副作用：<strong>不能在声明变量前访问它们，就算是<code>typeof</code>这样安全的操作符也不行</strong>。在声明前访问块绑定会导致错误，因为绑定还在临时死区（TDZ）中。</p>↵↵<p><code>let</code>和<code>const</code>的行为很多时候和<code>var</code>一致。然而，它们在循环中的行为运不一样。在<code>for-in</code>和<code>for-of</code>循环中，<code>let</code>和<code>const</code>都会每次迭代时创建新绑定，从而使循环体内创建的函数可以访问到相应的迭代值，而非最后一次迭代后的值（像使用<code>var</code>一样）。<code>let</code>在<code>for</code>循环中同样如此，但在<code>for</code>循环中使用<code>const</code>声明则有可能会引发错误。</p>↵↵<p>综合所述，在ES6中声明变量时，<strong>默认使用<code>const</code>，只在确实需要改变变量的值时使用<code>let</code>。</strong>这样就可以在某种程度中实现代码的不可变，从而防止某些错误的产生。</p>↵↵<div class="blog-author media"><a class="media-object" href="//weibo.com/w3cplus" target="_blank"><img src="/sites/default/files/blogs/author/airen.jpg"></a><div class="media-body"><h3 class="media-heading"><a href="//weibo.com/w3cplus" target="_blank">大漠</a></h3><div class="media-des">常用昵称“大漠”，W3CPlus创始人，目前就职于手淘。对HTML5、CSS3和Sass等前端脚本语言有非常深入的认识和丰富的实践经验，尤其专注对CSS3的研究，是国内最早研究和使用CSS3技术的一批人。CSS3、Sass和Drupal中国布道者。2014年出版《<a href="//www.w3cplus.com/book-comment.html" target="_blank">图解CSS3：核心技术与案例实战</a>》。</div></div></div>↵↵<p>如需转载，烦请注明出处：<a href="//www.w3cplus.com/javascript/es6-block-scoping.html">https://www.w3cplus.com/javascript/es6-block-scoping.html</a></p>↵</div></div></div><div class="field field-name-field-taxonomy field-type-taxonomy-term-reference field-label-hidden"><div class="field-items"><div class="field-item even"><a href="/blog/JavaScript" typeof="skos:Concept" property="rdfs:label skos:prefLabel" datatype="">JavaScript</a></div></div></div><div class="field field-name-field-blog-tag field-type-taxonomy-term-reference field-label-hidden"><div class="field-items"><div class="field-item even"><a href="/blog/tags/544.html" typeof="skos:Concept" property="rdfs:label skos:prefLabel" datatype="">ES6</a></div><div class="field-item odd"><a href="/blog/tags/540.html" typeof="skos:Concept" property="rdfs:label skos:prefLabel" datatype="">JavaScript学习笔记</a></div><div class="field-item even"><a href="/JavaScript" typeof="skos:Concept" property="rdfs:label skos:prefLabel" datatype="">JavaScript</a></div></div></div>);



